# Story 0.25: MATCH-EVENTS-001

## Status

Ready to Implement

---

## Story

**As a** developer,
**I want** match scores automatically recalculated when underlying data changes,
**so that** coordinators always see fresh, accurate match recommendations without manual intervention.

## Acceptance Criteria

### 1. Event Handler: User Profile Update
- [ ] File created: `apps/api/src/events/matching-triggers.ts`
- [ ] Function: `handleUserProfileUpdate(userId: string, db: SupabaseClient): Promise<void>`
- [ ] Triggered when user profile fields change (name, bio, title, company, etc.)
- [ ] Calls `engine.recalculateMatches(userId)` using TagBasedMatchingEngineV1
- [ ] Comprehensive dev-only logging: entry, userId, completion status, errors
- [ ] Error handling with try-catch, logs errors but does not throw (non-blocking)

### 2. Event Handler: User Tags Change
- [ ] Function: `handleUserTagsChange(userId: string, db: SupabaseClient): Promise<void>`
- [ ] Triggered when tags in `entity_tags` table change (INSERT, UPDATE, DELETE for user)
- [ ] Calls `engine.recalculateMatches(userId)` using TagBasedMatchingEngineV1
- [ ] Comprehensive dev-only logging: entry, userId, tagCount, completion status
- [ ] Error handling with try-catch, logs errors but does not throw (non-blocking)

### 3. Event Handler: Portfolio Company Tags Change
- [ ] Function: `handlePortfolioCompanyTagsChange(companyId: string, db: SupabaseClient): Promise<void>`
- [ ] Triggered when portfolio company tags change (INSERT, UPDATE, DELETE for portfolio_company)
- [ ] Fetches all mentees linked to portfolio company: `SELECT user_id FROM user_profiles WHERE portfolio_company_id = $1 AND deleted_at IS NULL`
- [ ] Calls `engine.recalculateMatches(userId)` for each mentee (tag inheritance affects mentee matches)
- [ ] Comprehensive dev-only logging: entry, companyId, affectedMenteeCount, progress, completion status
- [ ] Error handling with try-catch, logs errors but does not throw (non-blocking)

### 4. Event Handler: User Reputation Tier Change
- [ ] Function: `handleReputationTierChange(userId: string, db: SupabaseClient): Promise<void>`
- [ ] Triggered when `users.reputation_tier` changes
- [ ] Calls `engine.recalculateMatches(userId)` using TagBasedMatchingEngineV1
- [ ] Comprehensive dev-only logging: entry, userId, newTier, completion status
- [ ] Error handling with try-catch, logs errors but does not throw (non-blocking)

### 5. Initial Population Script
- [ ] File created: `apps/api/src/scripts/populate-match-cache.ts`
- [ ] Script: `populateMatchCache(options?: { limit?: number }): Promise<void>`
- [ ] Calls `engine.recalculateAllMatches(options)` using TagBasedMatchingEngineV1
- [ ] Can be run manually via CLI: `npm run populate-match-cache` (or `npm run populate-match-cache -- --limit 10` for testing)
- [ ] Comprehensive dev-only logging: start, batch progress (from engine), total users processed, duration, completion status
- [ ] Exit with code 0 on success, code 1 on error

### 6. Integration with Existing API Endpoints
- [ ] Integrate event handlers into existing API endpoints:
  - `PUT /api/users/me` (profile update) ‚Üí calls `handleUserProfileUpdate`
  - `PUT /api/users/:id/tags` (tag update) ‚Üí calls `handleUserTagsChange`
  - `PUT /api/portfolio-companies/:id/tags` (company tag update) ‚Üí calls `handlePortfolioCompanyTagsChange`
  - `PUT /api/users/:id/reputation` (reputation override, coordinator only) ‚Üí calls `handleReputationTierChange`
- [ ] All handlers called asynchronously (fire-and-forget pattern, do not block API responses)
- [ ] Logging confirms event handlers triggered: `[MATCHING] Triggered recalculation for user {userId}`

### 7. Comprehensive Dev-Only Logging
- [ ] All log points match architecture specification exactly (Section 8.8)
- [ ] Log format: `[MATCHING] {operation} { contextData }`
- [ ] Minimum 15 log points covering:
  - Entry/exit for each event handler
  - Trigger source (profile update, tag change, company tag change, reputation change)
  - Affected user IDs and counts
  - Engine method calls
  - Success/failure status
  - Error details
- [ ] All logs wrapped in `if (process.env.NODE_ENV === 'development')` check
- [ ] No logs in production environment

### 8. Integration Tests for Event Handlers
- [ ] Test file: `apps/api/src/events/__tests__/matching-triggers.test.ts`
- [ ] Uses centralized fixtures from `test/fixtures/matching.ts` (MANDATORY - no inline mocks)
- [ ] Test suites cover:
  - **handleUserProfileUpdate**: Triggers recalculation, passes correct userId, handles errors gracefully
  - **handleUserTagsChange**: Triggers recalculation, passes correct userId, handles errors gracefully
  - **handlePortfolioCompanyTagsChange**: Fetches linked mentees, triggers recalculation for each, handles errors gracefully
  - **handleReputationTierChange**: Triggers recalculation, passes correct userId, handles errors gracefully
  - **Error handling**: Engine errors logged but do not throw, API continues to function
- [ ] All tests use Arrange-Act-Assert pattern
- [ ] All tests have descriptive names: "should {expected behavior} when {condition}"
- [ ] Coverage report: `npm run test:coverage` shows ‚â•85% for matching-triggers.ts

### 9. Integration Tests for API Endpoints
- [ ] Extend existing API endpoint tests to verify event handlers fire:
  - `PUT /api/users/me` test: Spy on `handleUserProfileUpdate`, verify called with userId
  - `PUT /api/users/:id/tags` test: Spy on `handleUserTagsChange`, verify called with userId
  - `PUT /api/portfolio-companies/:id/tags` test: Spy on `handlePortfolioCompanyTagsChange`, verify called with companyId
  - `PUT /api/users/:id/reputation` test: Spy on `handleReputationTierChange`, verify called with userId
- [ ] All tests verify handlers called asynchronously (do not block API response)

### 10. Code Quality & Standards
- [ ] Follows coding standards from [14-coding-standards.md](../architecture/14-coding-standards.md)
- [ ] File length <200 lines per file (if >200, extract helpers to separate file)
- [ ] All public functions have JSDoc comments with `@param`, `@returns`, `@logging` tags
- [ ] No ESLint errors: `npm run lint` passes
- [ ] No TypeScript errors: `npm run type-check` passes
- [ ] Named exports only (no default exports)
- [ ] Proper error handling with try-catch blocks
- [ ] Errors logged but do not throw (non-blocking handlers)

## üö´ Out of Scope

This story focuses ONLY on event-driven triggers for match recalculation. The following are explicitly **NOT included**:

- ‚ùå Cloudflare Queues for background processing (Story 0.26 or future enhancement)
- ‚ùå Cache expiration logic (7-day TTL deferred to future enhancement)
- ‚ùå Admin UI for manual recalculation triggers (Epic 8)
- ‚ùå Real-time cache invalidation for coordinators (Epic 6)
- ‚ùå Webhooks for external systems (Epic 5: Airtable sync)
- ‚ùå Batch job scheduling (cron jobs deferred to future enhancement)
- ‚ùå Performance optimization (advanced batching, parallelization beyond Story 0.23)
- ‚ùå Cache warmup strategies (preemptive recalculation deferred to future)
- ‚ùå ML-based matching algorithms (future enhancement)

## üìö Dev Notes

### Architecture Context

**Event-Driven Cache Architecture** ([matching-cache-architecture.md](../architecture/matching-cache-architecture.md)):

This story implements the **event-driven recalculation triggers** that keep the match cache fresh:

1. **CALCULATE (Story 0.23)**: Expensive, polymorphic, background processing
   - Input: User A, User B, algorithm logic
   - Output: Score (0-100), explanation
   - Writes to `user_match_cache` table
   - **Interface**: `IMatchingEngine` (supports multiple algorithms)

2. **RETRIEVE (Story 0.24)**: Cheap, NOT polymorphic, on-demand
   - Input: User ID, optional filters
   - Output: Cached MatchResults
   - Reads from `user_match_cache` table
   - **No interface**: Plain `MatchingService` class

3. **TRIGGER (this story)**: Event-driven, asynchronous, non-blocking
   - Input: Data change event (profile, tags, reputation)
   - Output: Fresh cache entries
   - **Fire-and-forget**: Does not block API responses

**Key Principle**: Trigger recalculation on data changes, so cache is always fresh when coordinators access it.

### Why Fire-and-Forget Pattern?

**From First Principles** (matching-cache-architecture.md, lines 64-77):

- **API response time** must be <2s (NFR2) ‚Üí Cannot wait for expensive recalculation
- **Cache staleness** is acceptable (fresh within seconds) ‚Üí Asynchronous update is fine
- **Error handling** should not block user actions ‚Üí Log errors, continue serving requests
- **Scalability** requires decoupling ‚Üí API response independent of cache update

**Implementation Pattern**:
```typescript
// API endpoint (e.g., PUT /api/users/me)
bookingRoutes.openapi(updateProfileRoute, async (c) => {
  const user = c.get('user');
  const profileData = c.req.valid('json');

  // 1. Update profile synchronously
  const userService = new UserService(c.env.DB);
  const updatedProfile = await userService.updateProfile(user.id, profileData);

  // 2. Trigger recalculation asynchronously (fire-and-forget)
  handleUserProfileUpdate(user.id, c.env.DB).catch((err) => {
    if (process.env.NODE_ENV === 'development') {
      console.error('[MATCHING] Failed to trigger recalculation', { userId: user.id, error: err.message });
    }
  });

  // 3. Return response immediately (cache update happens in background)
  return c.json(updatedProfile, 200);
});
```

### Previous Story Insights

**From Story 0.22** (MATCH-INTERFACE-001):
- `IMatchingEngine` interface created in `apps/api/src/providers/matching/interface.ts`
- `user_match_cache` table exists with indexes on `user_id`, `match_score DESC`, `algorithm_version`, `calculated_at`
- RLS policy: Only coordinators can read cache table
- All logging format specifications defined in interface JSDoc

**From Story 0.23** (MATCH-TAG-001):
- `TagBasedMatchingEngineV1` implements `IMatchingEngine`
- `recalculateMatches(userId)` method available for single-user updates
- `recalculateAllMatches(options)` method available for batch processing
- Algorithm version: `'tag-based-v1'`
- Comprehensive dev-only logging for all operations
- Centralized fixtures created in `apps/api/src/test/fixtures/matching.ts`

**From Story 0.24** (MATCH-SERVICE-001):
- `MatchingService` class retrieves cached matches
- API endpoints: `POST /v1/matching/find-matches`, `POST /v1/matching/explain`
- Coordinators have read access to cache table
- Retrieval is fast (<100ms) because data is pre-calculated

### Data Model Context

**Source**: [4-data-models.md](../architecture/4-data-models.md) Section 4.8

**User Match Cache Table Schema** (created in Story 0.22):
```sql
CREATE TABLE user_match_cache (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  recommended_user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  match_score numeric(5,2) NOT NULL CHECK (match_score >= 0 AND match_score <= 100),
  match_explanation jsonb NOT NULL,
  algorithm_version text NOT NULL,
  calculated_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE(user_id, recommended_user_id, algorithm_version),
  CHECK (user_id != recommended_user_id)
);

-- Indexes for fast retrieval
CREATE INDEX idx_user_match_cache_user_id ON user_match_cache(user_id);
CREATE INDEX idx_user_match_cache_score ON user_match_cache(user_id, match_score DESC);
CREATE INDEX idx_user_match_cache_algorithm ON user_match_cache(algorithm_version);
CREATE INDEX idx_user_match_cache_calculated_at ON user_match_cache(calculated_at);
```

### Trigger Events

**When to Recalculate Matches**:

1. **User Profile Update** (FR13a, matching-cache-architecture.md):
   - User profile fields change: name, bio, title, company
   - **Trigger**: `PUT /api/users/me` endpoint
   - **Action**: `handleUserProfileUpdate(userId)` ‚Üí `engine.recalculateMatches(userId)`
   - **Rationale**: Profile changes may affect match explanations (not scores, but context)

2. **User Tags Change** (FR13a, matching-cache-architecture.md):
   - User tags added/removed in `entity_tags` table
   - **Trigger**: `PUT /api/users/:id/tags` endpoint (or tag management UI)
   - **Action**: `handleUserTagsChange(userId)` ‚Üí `engine.recalculateMatches(userId)`
   - **Rationale**: Tag changes directly affect match scores (60% weight in algorithm)

3. **Portfolio Company Tags Change** (FR13b, matching-cache-architecture.md):
   - Portfolio company tags added/removed in `entity_tags` table
   - **Trigger**: `PUT /api/portfolio-companies/:id/tags` endpoint (or Airtable sync)
   - **Action**: `handlePortfolioCompanyTagsChange(companyId)` ‚Üí Fetch linked mentees ‚Üí `engine.recalculateMatches(menteeId)` for each
   - **Rationale**: Mentees inherit company tags (Story 0.23), so company tag changes affect mentee match scores

4. **User Reputation Tier Change** (FR13a, matching-cache-architecture.md):
   - User reputation tier changes: bronze ‚Üí silver, etc.
   - **Trigger**: `PUT /api/users/:id/reputation` endpoint (coordinator override) or reputation recalculation (Epic 7)
   - **Action**: `handleReputationTierChange(userId)` ‚Üí `engine.recalculateMatches(userId)`
   - **Rationale**: Reputation tier affects match scores (20% weight in algorithm)

5. **Initial Population** (FR13, matching-cache-architecture.md):
   - Run once for existing users to populate cache
   - **Trigger**: Manual script execution or deployment step
   - **Action**: `populateMatchCache()` ‚Üí `engine.recalculateAllMatches()`
   - **Rationale**: Cache must be populated before coordinators can use matching UI

### Event Handler Implementation Details

**Event Handler Pattern**:
```typescript
// apps/api/src/events/matching-triggers.ts

import type { SupabaseClient } from '@supabase/supabase-js';
import { TagBasedMatchingEngineV1 } from '../providers/matching/tag-based.engine';

/**
 * Handle user profile update event
 *
 * Triggers match recalculation when user profile changes.
 * This is a fire-and-forget operation - errors are logged but not thrown.
 *
 * @param userId - User ID whose profile was updated
 * @param db - Supabase client instance
 *
 * @logging
 * - [MATCHING] handleUserProfileUpdate { userId }
 * - [MATCHING] Profile update triggered recalculation { userId }
 * - [MATCHING] Profile update recalculation failed { userId, error }
 */
export const handleUserProfileUpdate = async (
  userId: string,
  db: SupabaseClient
): Promise<void> => {
  if (process.env.NODE_ENV === 'development') {
    console.log('[MATCHING] handleUserProfileUpdate', { userId });
  }

  try {
    const engine = new TagBasedMatchingEngineV1(db);
    await engine.recalculateMatches(userId);

    if (process.env.NODE_ENV === 'development') {
      console.log('[MATCHING] Profile update triggered recalculation', { userId });
    }
  } catch (error) {
    if (process.env.NODE_ENV === 'development') {
      console.error('[MATCHING] Profile update recalculation failed', {
        userId,
        error: error instanceof Error ? error.message : String(error),
      });
    }
    // Do not throw - this is a non-blocking operation
  }
};

/**
 * Handle user tags change event
 *
 * Triggers match recalculation when user tags are added/removed.
 * This is a fire-and-forget operation - errors are logged but not thrown.
 *
 * @param userId - User ID whose tags were changed
 * @param db - Supabase client instance
 *
 * @logging
 * - [MATCHING] handleUserTagsChange { userId }
 * - [MATCHING] Tag change triggered recalculation { userId }
 * - [MATCHING] Tag change recalculation failed { userId, error }
 */
export const handleUserTagsChange = async (
  userId: string,
  db: SupabaseClient
): Promise<void> => {
  if (process.env.NODE_ENV === 'development') {
    console.log('[MATCHING] handleUserTagsChange', { userId });
  }

  try {
    const engine = new TagBasedMatchingEngineV1(db);
    await engine.recalculateMatches(userId);

    if (process.env.NODE_ENV === 'development') {
      console.log('[MATCHING] Tag change triggered recalculation', { userId });
    }
  } catch (error) {
    if (process.env.NODE_ENV === 'development') {
      console.error('[MATCHING] Tag change recalculation failed', {
        userId,
        error: error instanceof Error ? error.message : String(error),
      });
    }
    // Do not throw - this is a non-blocking operation
  }
};

/**
 * Handle portfolio company tags change event
 *
 * Triggers match recalculation for all mentees linked to the portfolio company.
 * Mentees inherit company tags, so company tag changes affect their match scores.
 * This is a fire-and-forget operation - errors are logged but not thrown.
 *
 * @param companyId - Portfolio company ID whose tags were changed
 * @param db - Supabase client instance
 *
 * @logging
 * - [MATCHING] handlePortfolioCompanyTagsChange { companyId }
 * - [MATCHING] Found linked mentees { companyId, menteeCount }
 * - [MATCHING] Company tag change triggered recalculation { companyId, menteesProcessed }
 * - [MATCHING] Company tag change recalculation failed { companyId, error }
 */
export const handlePortfolioCompanyTagsChange = async (
  companyId: string,
  db: SupabaseClient
): Promise<void> => {
  if (process.env.NODE_ENV === 'development') {
    console.log('[MATCHING] handlePortfolioCompanyTagsChange', { companyId });
  }

  try {
    // Fetch all mentees linked to this portfolio company
    const { data: mentees, error } = await db
      .from('user_profiles')
      .select('user_id')
      .eq('portfolio_company_id', companyId)
      .is('deleted_at', null);

    if (error) {
      throw new Error(`Failed to fetch linked mentees: ${error.message}`);
    }

    if (!mentees || mentees.length === 0) {
      if (process.env.NODE_ENV === 'development') {
        console.log('[MATCHING] No linked mentees found', { companyId });
      }
      return;
    }

    if (process.env.NODE_ENV === 'development') {
      console.log('[MATCHING] Found linked mentees', {
        companyId,
        menteeCount: mentees.length,
      });
    }

    // Recalculate matches for each mentee
    const engine = new TagBasedMatchingEngineV1(db);
    let processed = 0;

    for (const mentee of mentees) {
      try {
        await engine.recalculateMatches(mentee.user_id);
        processed++;
      } catch (err) {
        if (process.env.NODE_ENV === 'development') {
          console.error('[MATCHING] Mentee recalculation failed', {
            userId: mentee.user_id,
            error: err instanceof Error ? err.message : String(err),
          });
        }
        // Continue processing remaining mentees
      }
    }

    if (process.env.NODE_ENV === 'development') {
      console.log('[MATCHING] Company tag change triggered recalculation', {
        companyId,
        menteesProcessed: processed,
        totalMentees: mentees.length,
      });
    }
  } catch (error) {
    if (process.env.NODE_ENV === 'development') {
      console.error('[MATCHING] Company tag change recalculation failed', {
        companyId,
        error: error instanceof Error ? error.message : String(error),
      });
    }
    // Do not throw - this is a non-blocking operation
  }
};

/**
 * Handle user reputation tier change event
 *
 * Triggers match recalculation when user reputation tier changes.
 * This is a fire-and-forget operation - errors are logged but not thrown.
 *
 * @param userId - User ID whose reputation tier was changed
 * @param db - Supabase client instance
 *
 * @logging
 * - [MATCHING] handleReputationTierChange { userId }
 * - [MATCHING] Reputation change triggered recalculation { userId }
 * - [MATCHING] Reputation change recalculation failed { userId, error }
 */
export const handleReputationTierChange = async (
  userId: string,
  db: SupabaseClient
): Promise<void> => {
  if (process.env.NODE_ENV === 'development') {
    console.log('[MATCHING] handleReputationTierChange', { userId });
  }

  try {
    const engine = new TagBasedMatchingEngineV1(db);
    await engine.recalculateMatches(userId);

    if (process.env.NODE_ENV === 'development') {
      console.log('[MATCHING] Reputation change triggered recalculation', { userId });
    }
  } catch (error) {
    if (process.env.NODE_ENV === 'development') {
      console.error('[MATCHING] Reputation change recalculation failed', {
        userId,
        error: error instanceof Error ? error.message : String(error),
      });
    }
    // Do not throw - this is a non-blocking operation
  }
};
```

### Initial Population Script

**Purpose**: Populate cache for all existing users before coordinators start using matching UI.

**Script Location**: `apps/api/src/scripts/populate-match-cache.ts`

**Implementation**:
```typescript
// apps/api/src/scripts/populate-match-cache.ts

import { createClient } from '@supabase/supabase-js';
import { TagBasedMatchingEngineV1 } from '../providers/matching/tag-based.engine';

/**
 * Populate match cache for all users
 *
 * This script runs the initial cache population using the tag-based matching algorithm.
 * Run manually via CLI: `npm run populate-match-cache`
 * For testing: `npm run populate-match-cache -- --limit 10`
 *
 * @param options - Optional limit for testing
 *
 * @logging
 * - [MATCHING] Starting cache population { limit }
 * - [MATCHING] Cache population completed { totalUsers, duration }
 * - [MATCHING] Cache population failed { error }
 */
const populateMatchCache = async (options?: { limit?: number }): Promise<void> => {
  const startTime = Date.now();

  if (process.env.NODE_ENV === 'development') {
    console.log('[MATCHING] Starting cache population', {
      limit: options?.limit || 'all users',
    });
  }

  try {
    // Initialize Supabase client
    const supabaseUrl = process.env.SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Missing Supabase environment variables');
    }

    const db = createClient(supabaseUrl, supabaseKey);

    // Initialize matching engine
    const engine = new TagBasedMatchingEngineV1(db);

    // Recalculate all matches
    await engine.recalculateAllMatches(options);

    const duration = Date.now() - startTime;

    if (process.env.NODE_ENV === 'development') {
      console.log('[MATCHING] Cache population completed', {
        duration: `${duration}ms`,
      });
    }

    process.exit(0);
  } catch (error) {
    if (process.env.NODE_ENV === 'development') {
      console.error('[MATCHING] Cache population failed', {
        error: error instanceof Error ? error.message : String(error),
      });
    }

    process.exit(1);
  }
};

// Parse command-line arguments
const args = process.argv.slice(2);
const limitArg = args.find((arg) => arg.startsWith('--limit='));
const limit = limitArg ? parseInt(limitArg.split('=')[1], 10) : undefined;

// Run script
populateMatchCache({ limit });
```

**Package.json Script**:
```json
{
  "scripts": {
    "populate-match-cache": "tsx apps/api/src/scripts/populate-match-cache.ts"
  }
}
```

### File Locations

**Source**: [9-unified-project-structure.md](../architecture/9-unified-project-structure.md)

```
apps/api/src/
‚îú‚îÄ‚îÄ events/
‚îÇ   ‚îú‚îÄ‚îÄ matching-triggers.ts              # üéØ THIS STORY (event handlers)
‚îÇ   ‚îî‚îÄ‚îÄ __tests__/
‚îÇ       ‚îî‚îÄ‚îÄ matching-triggers.test.ts     # üéØ THIS STORY (integration tests)
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îî‚îÄ‚îÄ populate-match-cache.ts           # üéØ THIS STORY (initial population script)
‚îú‚îÄ‚îÄ providers/
‚îÇ   ‚îî‚îÄ‚îÄ matching/
‚îÇ       ‚îú‚îÄ‚îÄ interface.ts                  # ‚úÖ Created in Story 0.22
‚îÇ       ‚îú‚îÄ‚îÄ tag-based.engine.ts           # ‚úÖ Created in Story 0.23
‚îÇ       ‚îî‚îÄ‚îÄ __tests__/
‚îÇ           ‚îî‚îÄ‚îÄ tag-based.engine.test.ts  # ‚úÖ Created in Story 0.23
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ matching.service.ts               # ‚úÖ Created in Story 0.24
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ matching.ts                       # ‚úÖ Created in Story 0.24
‚îÇ   ‚îú‚îÄ‚îÄ users.ts                          # ‚úÖ Existing (modify to add trigger)
‚îÇ   ‚îú‚îÄ‚îÄ portfolio-companies.ts            # ‚úÖ Existing (modify to add trigger)
‚îÇ   ‚îî‚îÄ‚îÄ __tests__/
‚îÇ       ‚îú‚îÄ‚îÄ matching.routes.test.ts       # ‚úÖ Created in Story 0.24
‚îÇ       ‚îú‚îÄ‚îÄ users.routes.test.ts          # üéØ THIS STORY (extend with trigger tests)
‚îÇ       ‚îî‚îÄ‚îÄ portfolio-companies.routes.test.ts # üéØ THIS STORY (extend with trigger tests)
‚îî‚îÄ‚îÄ test/
    ‚îî‚îÄ‚îÄ fixtures/
        ‚îî‚îÄ‚îÄ matching.ts                   # ‚úÖ Created in Story 0.23
```

### Integration with API Endpoints

**Example: Profile Update Endpoint**:
```typescript
// apps/api/src/routes/users.ts

import { handleUserProfileUpdate } from '../events/matching-triggers';

// PUT /api/users/me
userRoutes.openapi(updateProfileRoute, async (c) => {
  const user = c.get('user');
  const profileData = c.req.valid('json');

  // 1. Update profile synchronously
  const userService = new UserService(c.env.DB);
  const updatedProfile = await userService.updateProfile(user.id, profileData);

  // 2. Trigger recalculation asynchronously (fire-and-forget)
  handleUserProfileUpdate(user.id, c.env.DB).catch((err) => {
    if (process.env.NODE_ENV === 'development') {
      console.error('[MATCHING] Failed to trigger recalculation', {
        userId: user.id,
        error: err.message,
      });
    }
  });

  // 3. Return response immediately
  return c.json(updatedProfile, 200);
});
```

**Example: Tag Update Endpoint**:
```typescript
// apps/api/src/routes/users.ts

import { handleUserTagsChange } from '../events/matching-triggers';

// PUT /api/users/:id/tags
userRoutes.openapi(updateTagsRoute, async (c) => {
  const { id } = c.req.valid('param');
  const { tags } = c.req.valid('json');

  // 1. Update tags synchronously
  const tagService = new TagService(c.env.DB);
  await tagService.updateUserTags(id, tags);

  // 2. Trigger recalculation asynchronously (fire-and-forget)
  handleUserTagsChange(id, c.env.DB).catch((err) => {
    if (process.env.NODE_ENV === 'development') {
      console.error('[MATCHING] Failed to trigger recalculation', {
        userId: id,
        error: err.message,
      });
    }
  });

  // 3. Return response immediately
  return c.json({ success: true }, 200);
});
```

### Testing Strategy

**Source**: [13-testing-strategy.md](../architecture/13-testing-strategy.md) Section 13.7, Lines 1811-1863

**Coverage Target**: 85% for `matching-triggers.ts`

**Test Framework**: Vitest 3.x
**Test Files**:
- `apps/api/src/events/__tests__/matching-triggers.test.ts` (integration tests)
- Extend existing API route tests: `users.routes.test.ts`, `portfolio-companies.routes.test.ts`

**Fixtures**: `apps/api/src/test/fixtures/matching.ts` (MANDATORY - created in Story 0.23)

### Integration Test Examples (Event Handlers)

```typescript
// apps/api/src/events/__tests__/matching-triggers.test.ts

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { handleUserProfileUpdate, handleUserTagsChange, handlePortfolioCompanyTagsChange, handleReputationTierChange } from '../matching-triggers';
import { createMockUser } from '@/test/fixtures/matching';
import type { SupabaseClient } from '@supabase/supabase-js';

describe('Matching Event Triggers', () => {
  let mockDb: SupabaseClient;
  let engineSpy: any;

  beforeEach(() => {
    mockDb = createMockSupabaseClient();
    engineSpy = vi.spyOn(TagBasedMatchingEngineV1.prototype, 'recalculateMatches');
  });

  describe('handleUserProfileUpdate', () => {
    it('should trigger recalculation for user', async () => {
      const userId = 'user-123';

      await handleUserProfileUpdate(userId, mockDb);

      expect(engineSpy).toHaveBeenCalledWith(userId);
    });

    it('should not throw error if recalculation fails', async () => {
      const userId = 'user-123';
      engineSpy.mockRejectedValue(new Error('Database error'));

      await expect(handleUserProfileUpdate(userId, mockDb)).resolves.not.toThrow();
    });
  });

  describe('handleUserTagsChange', () => {
    it('should trigger recalculation for user', async () => {
      const userId = 'user-123';

      await handleUserTagsChange(userId, mockDb);

      expect(engineSpy).toHaveBeenCalledWith(userId);
    });
  });

  describe('handlePortfolioCompanyTagsChange', () => {
    it('should recalculate matches for all linked mentees', async () => {
      const companyId = 'company-123';
      const mentees = [
        { user_id: 'mentee-1' },
        { user_id: 'mentee-2' },
        { user_id: 'mentee-3' },
      ];

      mockDb.from('user_profiles').select.mockResolvedValue({
        data: mentees,
        error: null,
      });

      await handlePortfolioCompanyTagsChange(companyId, mockDb);

      expect(engineSpy).toHaveBeenCalledTimes(3);
      expect(engineSpy).toHaveBeenCalledWith('mentee-1');
      expect(engineSpy).toHaveBeenCalledWith('mentee-2');
      expect(engineSpy).toHaveBeenCalledWith('mentee-3');
    });

    it('should handle no linked mentees gracefully', async () => {
      const companyId = 'company-123';

      mockDb.from('user_profiles').select.mockResolvedValue({
        data: [],
        error: null,
      });

      await handlePortfolioCompanyTagsChange(companyId, mockDb);

      expect(engineSpy).not.toHaveBeenCalled();
    });

    it('should continue processing if one mentee fails', async () => {
      const companyId = 'company-123';
      const mentees = [
        { user_id: 'mentee-1' },
        { user_id: 'mentee-2' },
        { user_id: 'mentee-3' },
      ];

      mockDb.from('user_profiles').select.mockResolvedValue({
        data: mentees,
        error: null,
      });

      // Fail on second mentee
      engineSpy
        .mockResolvedValueOnce(undefined) // mentee-1 succeeds
        .mockRejectedValueOnce(new Error('DB error')) // mentee-2 fails
        .mockResolvedValueOnce(undefined); // mentee-3 succeeds

      await handlePortfolioCompanyTagsChange(companyId, mockDb);

      expect(engineSpy).toHaveBeenCalledTimes(3);
    });
  });

  describe('handleReputationTierChange', () => {
    it('should trigger recalculation for user', async () => {
      const userId = 'user-123';

      await handleReputationTierChange(userId, mockDb);

      expect(engineSpy).toHaveBeenCalledWith(userId);
    });
  });
});
```

### Integration Test Examples (API Endpoints)

```typescript
// apps/api/src/routes/__tests__/users.routes.test.ts

import { describe, it, expect, vi } from 'vitest';
import { testClient } from 'hono/testing';
import { app } from '../../index';
import * as matchingTriggers from '../../events/matching-triggers';

describe('PUT /api/users/me', () => {
  it('should trigger match recalculation after profile update', async () => {
    const spy = vi.spyOn(matchingTriggers, 'handleUserProfileUpdate');

    const response = await testClient(app).users.me.$put({
      headers: { Authorization: `Bearer ${userToken}` },
      json: { name: 'Updated Name', bio: 'Updated bio' },
    });

    expect(response.status).toBe(200);
    expect(spy).toHaveBeenCalledWith('user-123', expect.anything());
  });

  it('should not block response if recalculation fails', async () => {
    const spy = vi
      .spyOn(matchingTriggers, 'handleUserProfileUpdate')
      .mockRejectedValue(new Error('Engine error'));

    const response = await testClient(app).users.me.$put({
      headers: { Authorization: `Bearer ${userToken}` },
      json: { name: 'Updated Name' },
    });

    // Response should succeed even if recalculation fails
    expect(response.status).toBe(200);
    expect(spy).toHaveBeenCalled();
  });
});
```

### Test Execution Commands

```bash
# Run integration tests for event handlers
npm run test -- matching-triggers.test.ts

# Run extended API endpoint tests
npm run test -- users.routes.test.ts
npm run test -- portfolio-companies.routes.test.ts

# Run all matching tests with coverage
npm run test:coverage -- matching

# Watch mode for development
npm run test:watch -- matching
```

### Performance Considerations

**Source**: [13-testing-strategy.md](../architecture/13-testing-strategy.md) Lines 1842-1863

**Performance Targets**:
- **Cache Write (single user)**: < 500ms (Story 0.23 target)
- **Cache Write (100 users)**: < 1 minute (Story 0.23 target)
- **API Response Time**: < 2s (NFR2) ‚Üí Event handlers must not block responses

**Optimizations**:
- **Fire-and-forget pattern**: API returns immediately, recalculation happens asynchronously
- **Error handling**: Errors logged but do not throw (non-blocking)
- **Batch processing**: `recalculateAllMatches` uses batching (Story 0.23)

**Scalability Roadmap** (Post-MVP):
- **Cloudflare Queues**: Offload recalculation to background queues for reliability
- **Cache expiration**: 7-day TTL to reduce stale data
- **Incremental updates**: Track changed users, recalculate only affected pairs

## üîó Tasks / Subtasks

### Task 1: Create Event Handler Functions (AC: 1, 2, 3, 4)
- [ ] Create file: `apps/api/src/events/matching-triggers.ts`
- [ ] Import dependencies: SupabaseClient, TagBasedMatchingEngineV1
- [ ] Implement `handleUserProfileUpdate(userId, db)`:
  - Add entry log (dev-only)
  - Initialize TagBasedMatchingEngineV1
  - Call `engine.recalculateMatches(userId)`
  - Add completion log (dev-only)
  - Wrap in try-catch, log errors but do not throw
- [ ] Implement `handleUserTagsChange(userId, db)`:
  - Add entry log (dev-only)
  - Initialize TagBasedMatchingEngineV1
  - Call `engine.recalculateMatches(userId)`
  - Add completion log (dev-only)
  - Wrap in try-catch, log errors but do not throw
- [ ] Implement `handlePortfolioCompanyTagsChange(companyId, db)`:
  - Add entry log (dev-only)
  - Fetch linked mentees: `SELECT user_id FROM user_profiles WHERE portfolio_company_id = $1 AND deleted_at IS NULL`
  - Handle "no mentees" case gracefully
  - Add log with mentee count (dev-only)
  - Initialize TagBasedMatchingEngineV1
  - Loop through mentees, call `engine.recalculateMatches(menteeId)` for each
  - Continue processing if one mentee fails (log error, continue loop)
  - Add completion log with menteesProcessed count (dev-only)
  - Wrap in try-catch, log errors but do not throw
- [ ] Implement `handleReputationTierChange(userId, db)`:
  - Add entry log (dev-only)
  - Initialize TagBasedMatchingEngineV1
  - Call `engine.recalculateMatches(userId)`
  - Add completion log (dev-only)
  - Wrap in try-catch, log errors but do not throw
- [ ] Add comprehensive JSDoc comments to all functions
- [ ] Export all handler functions
- [ ] Test imports and compilation: `npm run type-check`

### Task 2: Create Initial Population Script (AC: 5)
- [ ] Create file: `apps/api/src/scripts/populate-match-cache.ts`
- [ ] Import dependencies: createClient from @supabase/supabase-js, TagBasedMatchingEngineV1
- [ ] Implement `populateMatchCache(options?)`:
  - Parse environment variables: SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY
  - Add entry log (dev-only)
  - Initialize Supabase client
  - Initialize TagBasedMatchingEngineV1
  - Call `engine.recalculateAllMatches(options)`
  - Add completion log with duration (dev-only)
  - Exit with code 0 on success
  - Wrap in try-catch, log errors, exit with code 1 on error
- [ ] Parse command-line arguments: `--limit=N`
- [ ] Call `populateMatchCache({ limit })`
- [ ] Add npm script to `package.json`: `"populate-match-cache": "tsx apps/api/src/scripts/populate-match-cache.ts"`
- [ ] Test script locally: `npm run populate-match-cache -- --limit=5`

### Task 3: Integrate Event Handlers into API Endpoints (AC: 6)
- [ ] Identify existing API endpoints:
  - `PUT /api/users/me` (profile update)
  - `PUT /api/users/:id/tags` (tag update)
  - `PUT /api/portfolio-companies/:id/tags` (company tag update)
  - `PUT /api/users/:id/reputation` (reputation override, coordinator only)
- [ ] Modify `apps/api/src/routes/users.ts`:
  - Import `handleUserProfileUpdate`, `handleUserTagsChange`, `handleReputationTierChange`
  - Add trigger after profile update: `handleUserProfileUpdate(userId, db).catch(logError)`
  - Add trigger after tag update: `handleUserTagsChange(userId, db).catch(logError)`
  - Add trigger after reputation update: `handleReputationTierChange(userId, db).catch(logError)`
  - Ensure all triggers use fire-and-forget pattern (do not await)
- [ ] Modify `apps/api/src/routes/portfolio-companies.ts`:
  - Import `handlePortfolioCompanyTagsChange`
  - Add trigger after company tag update: `handlePortfolioCompanyTagsChange(companyId, db).catch(logError)`
  - Ensure trigger uses fire-and-forget pattern (do not await)
- [ ] Add log confirmation: `[MATCHING] Triggered recalculation for user {userId}`
- [ ] Test API endpoints locally: `npm run dev` (Wrangler)

### Task 4: Write Integration Tests for Event Handlers (AC: 8)
- [ ] Create test file: `apps/api/src/events/__tests__/matching-triggers.test.ts`
- [ ] Import Vitest, event handlers, fixtures from `@/test/fixtures/matching`
- [ ] Mock SupabaseClient and TagBasedMatchingEngineV1
- [ ] Write test suite: `describe('Matching Event Triggers')`
- [ ] Test `handleUserProfileUpdate`:
  - Triggers recalculation (spy on engine method)
  - Passes correct userId
  - Does not throw error if recalculation fails
- [ ] Test `handleUserTagsChange`:
  - Triggers recalculation (spy on engine method)
  - Passes correct userId
  - Does not throw error if recalculation fails
- [ ] Test `handlePortfolioCompanyTagsChange`:
  - Fetches linked mentees from database
  - Triggers recalculation for each mentee
  - Handles "no mentees" case gracefully
  - Continues processing if one mentee fails
- [ ] Test `handleReputationTierChange`:
  - Triggers recalculation (spy on engine method)
  - Passes correct userId
  - Does not throw error if recalculation fails
- [ ] Run coverage: `npm run test:coverage -- matching-triggers.test.ts`
- [ ] Verify ‚â•85% coverage

### Task 5: Extend API Endpoint Tests (AC: 9)
- [ ] Extend `apps/api/src/routes/__tests__/users.routes.test.ts`:
  - Test `PUT /api/users/me`: Spy on `handleUserProfileUpdate`, verify called with userId
  - Test `PUT /api/users/:id/tags`: Spy on `handleUserTagsChange`, verify called with userId
  - Test `PUT /api/users/:id/reputation`: Spy on `handleReputationTierChange`, verify called with userId
  - Verify all handlers called asynchronously (do not block API response)
  - Verify API response succeeds even if handler fails
- [ ] Extend `apps/api/src/routes/__tests__/portfolio-companies.routes.test.ts`:
  - Test `PUT /api/portfolio-companies/:id/tags`: Spy on `handlePortfolioCompanyTagsChange`, verify called with companyId
  - Verify handler called asynchronously (does not block API response)
  - Verify API response succeeds even if handler fails
- [ ] Run coverage: `npm run test:coverage -- *.routes.test.ts`
- [ ] Verify all API endpoint tests pass

### Task 6: Code Quality & Documentation (AC: 10)
- [ ] Add JSDoc comments to all event handler functions
- [ ] Add JSDoc `@param`, `@returns`, `@logging` tags
- [ ] Add file header comment explaining event-driven architecture
- [ ] Add inline comments for complex logic (portfolio company mentee fetching)
- [ ] Run `npm run lint` - fix all errors
- [ ] Run `npm run type-check` - fix all errors
- [ ] Check file lengths: if >200 lines, extract helpers to separate file
- [ ] Verify named exports only (no default exports)
- [ ] Verify all dev-only logs wrapped in `if (process.env.NODE_ENV === 'development')`
- [ ] Verify all handlers use try-catch with non-throwing error handling

## üìù Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | 1.0 | Initial story draft created | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
