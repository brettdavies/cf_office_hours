# Story 0.22: MATCH-INTERFACE-001

## Status

Ready to Implement

---

## Story

**As a** backend developer,
**I want** a well-defined `IMatchingEngine` interface and database cache schema,
**so that** we can implement pluggable matching algorithms with efficient caching and instant retrieval for the coordinator UI.

## Acceptance Criteria

1. **Database Migration Created**
   - Migration file creates `user_match_cache` table with exact schema from architecture docs
   - All columns have correct types: `uuid`, `numeric(5,2)`, `jsonb`, `text`, `timestamptz`
   - Foreign key constraints: `user_id` and `recommended_user_id` reference `users(id) ON DELETE CASCADE`
   - Check constraints: `match_score >= 0 AND match_score <= 100`, `user_id != recommended_user_id`
   - Unique constraint: `(user_id, recommended_user_id, algorithm_version)`
   - All 4 indexes created: `user_id`, `(user_id, match_score DESC)`, `algorithm_version`, `calculated_at`
   - RLS enabled with "Coordinators can view all match cache" policy
   - Migration runs successfully: `supabase db reset` completes without errors

2. **TypeScript Interface Defined**
   - File created: `apps/api/src/providers/matching/interface.ts`
   - `IMatchingEngine` interface exported with all 3 methods:
     - `recalculateMatches(userId: string): Promise<void>`
     - `recalculateAllMatches(options?: BulkRecalculationOptions): Promise<void>`
     - `getAlgorithmVersion(): string`
   - `BulkRecalculationOptions` interface exported with optional fields:
     - `limit?: number` (for testing/gradual rollout)
     - `modifiedAfter?: Date` (process only recent changes)
     - `batchSize?: number` (default 100)
   - JSDoc comments match architecture documentation exactly
   - JSDoc includes `@logging` sections for each method with exact log format

3. **Supporting TypeScript Types**
   - `MatchExplanation` interface exported in same file with fields: `tagOverlap`, `stageMatch`, `reputationCompatible`, `summary`
   - `UserMatchCache` type defined matching database schema

4. **Documentation & Comments**
   - Interface file has header comment explaining calculation vs retrieval pattern
   - Each method has `@param`, `@returns`, `@logging` JSDoc tags
   - Code comments explain "algorithm version is data, not behavior" principle
   - Example usage comment included

5. **Validation Complete**
   - Migration verified: Table exists with correct schema
   - Schema validation: Constraints tested with insert attempts
   - Foreign key test: Invalid `user_id` rejected
   - Check constraint test: `match_score = 101` rejected
   - Unique constraint test: Duplicate inserts rejected
   - RLS test: Non-coordinator cannot read, coordinator can read
   - TypeScript compilation: `npm run type-check` passes
   - Interface importable: Test import compiles successfully

6. **Code Quality**
   - Migration follows naming convention: `YYYYMMDDHHMMSS_create_user_match_cache.sql`
   - SQL formatted with consistent indentation (2 spaces)
   - TypeScript follows project conventions
   - No ESLint errors: `npm run lint` passes
   - File exports are explicit (no default exports for interfaces)

## Tasks / Subtasks

- [ ] **Task 1: Apply Database Migration** (AC: 1)
  - [ ] Use MCP tool `mcp__supabase_local__apply_migration` with name `create_user_match_cache`
  - [ ] Copy exact migration SQL from Dev Notes → Migration Script Template
  - [ ] Verify migration runs without errors
  - [ ] Confirm table exists: `\d user_match_cache`
  - [ ] Confirm indexes created: `\di user_match_cache*`

- [ ] **Task 2: Create TypeScript Interface Directory & File** (AC: 2, 3, 4)
  - [ ] Create directory: `apps/api/src/providers/matching/`
  - [ ] Create file: `interface.ts`
  - [ ] Copy interface definition from Dev Notes → Interface Definition Template
  - [ ] Add all JSDoc comments with `@param`, `@returns`, `@logging` tags
  - [ ] Add header comment explaining calculation vs retrieval pattern
  - [ ] Export `IMatchingEngine` interface
  - [ ] Export `BulkRecalculationOptions` interface
  - [ ] Export `MatchExplanation` interface
  - [ ] Export `UserMatchCache` interface
  - [ ] Add example usage comment

- [ ] **Task 3: Verify TypeScript Compilation** (AC: 5)
  - [ ] Run `npm run type-check` - must pass
  - [ ] Run `npm run lint` - must pass
  - [ ] Create temporary test import file to verify interface is importable
  - [ ] Delete test import file after verification

- [ ] **Task 4: Test Database Constraints** (AC: 1, 5)
  - [ ] Use MCP tool `mcp__supabase_local__execute_sql`
  - [ ] Test foreign key constraint: Insert with invalid `user_id` (should FAIL)
  - [ ] Test check constraint: Insert with `match_score = 101` (should FAIL)
  - [ ] Test unique constraint: Insert duplicate `(user_id, recommended_user_id, algorithm_version)` (should FAIL)
  - [ ] Test self-match constraint: Insert with `user_id = recommended_user_id` (should FAIL)

- [ ] **Task 5: Test RLS Policies** (AC: 1, 5)
  - [ ] Query as coordinator user (should succeed)
  - [ ] Query as non-coordinator user (should return empty or fail)
  - [ ] Verify RLS policy name: "Coordinators can view all match cache"

- [ ] **Task 6: Final Validation** (AC: 6)
  - [ ] Verify migration naming convention followed
  - [ ] Verify SQL indentation (2 spaces)
  - [ ] Verify TypeScript coding standards followed
  - [ ] Verify no default exports used
  - [ ] Mark all acceptance criteria as complete

## Dev Notes

### Architecture Principle: Calculation vs Retrieval

**Key Design Pattern:**
- **Calculation is polymorphic** → `IMatchingEngine` interface allows swappable algorithms
- **Retrieval is NOT polymorphic** → Simple SQL queries against cache table
- **Algorithm version is data** (column filter), not behavior

**Event-Driven Pattern:**
```
Event Triggers → IMatchingEngine.recalculateMatches() → Cache Write → Fast Retrieval
```

**Trigger Events** (future stories):
- User profile updated
- User tags changed
- Portfolio company tags changed
- User reputation tier changed

**Retrieval** (future stories):
- Coordinator loads matching UI
- API query with `WHERE algorithm_version = 'tag-based-v1'` filter
- Always fast (< 100ms, no calculation)

### Current Project Structure

```
apps/api/src/
├── repositories/          # ✅ Exists (user, booking, availability)
├── services/              # ✅ Exists (booking, auth services)
├── middleware/            # ✅ Exists (auth, error handling)
├── routes/                # ✅ Exists (booking, availability routes)
├── lib/                   # ✅ Exists (db, errors)
└── providers/             # ❌ DOES NOT EXIST YET
    └── matching/          # 🎯 THIS STORY CREATES THIS
        └── interface.ts   # 🎯 IMatchingEngine interface
```

### Migration Script Template

**Migration Name:** `create_user_match_cache`

**SQL (copy exactly):**
```sql
-- Migration: create_user_match_cache
-- Story: 0.22 - MATCH-INTERFACE-001
-- Description: Creates user_match_cache table with indexes and RLS for matching algorithm results

-- Create user_match_cache table
CREATE TABLE user_match_cache (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Who is this recommendation FOR
  user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,

  -- Who is being recommended
  recommended_user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,

  -- Match score (0-100)
  match_score numeric(5,2) NOT NULL CHECK (match_score >= 0 AND match_score <= 100),

  -- Detailed explanation (JSON)
  match_explanation jsonb NOT NULL,

  -- Which algorithm calculated this
  algorithm_version text NOT NULL,

  -- When was this calculated
  calculated_at timestamptz NOT NULL DEFAULT now(),

  -- Audit fields
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),

  -- Constraints
  UNIQUE(user_id, recommended_user_id, algorithm_version),
  CHECK (user_id != recommended_user_id)
);

-- Indexes for fast retrieval
CREATE INDEX idx_user_match_cache_user_id ON user_match_cache(user_id);
CREATE INDEX idx_user_match_cache_score ON user_match_cache(user_id, match_score DESC);
CREATE INDEX idx_user_match_cache_algorithm ON user_match_cache(algorithm_version);
CREATE INDEX idx_user_match_cache_calculated_at ON user_match_cache(calculated_at);

-- RLS Policy: Coordinators only
ALTER TABLE user_match_cache ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Coordinators can view all match cache"
  ON user_match_cache
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
        AND users.role = 'coordinator'
    )
  );
```

### Interface Definition Template

**File:** `apps/api/src/providers/matching/interface.ts`

**TypeScript (copy exactly):**
```typescript
/**
 * Matching engine interface for calculating and caching user matches
 *
 * ARCHITECTURE PRINCIPLE:
 * - Calculation is polymorphic (implementations of this interface)
 * - Retrieval is NOT polymorphic (simple SQL queries)
 * - Algorithm version is data (column filter), not behavior
 *
 * Implementations calculate match scores in the background and write
 * results to the user_match_cache table. This enables instant retrieval
 * for the UI without expensive calculations on every request.
 *
 * @example
 * const engine = new TagBasedMatchingEngineV1(db);
 * await engine.recalculateMatches(userId); // Background calculation
 */
export interface IMatchingEngine {
  /**
   * Recalculate matches for a specific user
   * Writes results to user_match_cache table
   *
   * @param userId - User ID to recalculate matches for
   *
   * @logging
   * - [MATCHING] recalculateMatches { userId, algorithmVersion }
   * - [MATCHING] Fetched potential matches { userId, potentialMatchCount }
   * - [MATCHING] Calculated scores { userId, matchCount, avgScore }
   * - [MATCHING] Wrote to cache { userId, cachedMatchCount }
   */
  recalculateMatches(userId: string): Promise<void>;

  /**
   * Recalculate matches for all users (batch operation)
   * Used for initial population or admin-triggered recalculation
   *
   * @param options - Bulk operation options
   *
   * @logging
   * - [MATCHING] recalculateAllMatches { algorithmVersion, options }
   * - [MATCHING] Processing batch { currentBatch, totalUsers }
   * - [MATCHING] Batch complete { processedCount, avgTimePerUser }
   */
  recalculateAllMatches(options?: BulkRecalculationOptions): Promise<void>;

  /**
   * Get the algorithm version identifier
   * Used to tag cache entries with algorithm version
   *
   * @returns Algorithm version string (e.g., 'tag-based-v1', 'ml-v2')
   */
  getAlgorithmVersion(): string;
}

/**
 * Options for bulk recalculation operations
 */
export interface BulkRecalculationOptions {
  /** Limit number of users to process (for testing/gradual rollout) */
  limit?: number;

  /** Process only users modified after this date */
  modifiedAfter?: Date;

  /** Batch size for processing (default: 100) */
  batchSize?: number;
}

/**
 * Match explanation stored in user_match_cache.match_explanation (JSONB)
 */
export interface MatchExplanation {
  tagOverlap: Array<{ category: string; tag: string }>;
  stageMatch: boolean;
  reputationCompatible: boolean;
  summary: string;
}

/**
 * User match cache row (matches database schema)
 */
export interface UserMatchCache {
  id: string;
  user_id: string;
  recommended_user_id: string;
  match_score: number; // 0-100
  match_explanation: MatchExplanation;
  algorithm_version: string;
  calculated_at: Date;
  created_at: Date;
  updated_at: Date;
}
```

### Common Pitfalls to Avoid

❌ **DO NOT** implement any concrete matching engine in this story
✅ **DO** create only the interface definition

❌ **DO NOT** create MatchingService or retrieval logic
✅ **DO** focus only on interface contract and database schema

❌ **DO NOT** add API routes or event triggers
✅ **DO** prepare foundation for future stories to build upon

❌ **DO NOT** modify existing migrations or tables
✅ **DO** create new migration file for user_match_cache only

❌ **DO NOT** add default exports for interfaces
✅ **DO** use named exports: `export interface IMatchingEngine`

### Constraint Testing SQL

**Test Foreign Key Constraint:**
```sql
-- Should FAIL (invalid user_id)
INSERT INTO user_match_cache (user_id, recommended_user_id, match_score, match_explanation, algorithm_version)
VALUES ('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000001', 50, '{}', 'test-v1');
```

**Test Check Constraint (score > 100):**
```sql
-- Should FAIL
INSERT INTO user_match_cache (user_id, recommended_user_id, match_score, match_explanation, algorithm_version)
SELECT
  id as user_id,
  (SELECT id FROM users WHERE id != user_id LIMIT 1) as recommended_user_id,
  101 as match_score,
  '{}' as match_explanation,
  'test-v1' as algorithm_version
FROM users LIMIT 1;
```

**Test Check Constraint (self-match):**
```sql
-- Should FAIL
INSERT INTO user_match_cache (user_id, recommended_user_id, match_score, match_explanation, algorithm_version)
SELECT
  id as user_id,
  id as recommended_user_id,
  50 as match_score,
  '{}' as match_explanation,
  'test-v1' as algorithm_version
FROM users LIMIT 1;
```

**Test Unique Constraint:**
```sql
-- Insert valid row
INSERT INTO user_match_cache (user_id, recommended_user_id, match_score, match_explanation, algorithm_version)
SELECT
  u1.id as user_id,
  u2.id as recommended_user_id,
  50 as match_score,
  '{"tagOverlap": [], "stageMatch": false, "reputationCompatible": true, "summary": "test"}' as match_explanation,
  'test-v1' as algorithm_version
FROM users u1, users u2
WHERE u1.id != u2.id
LIMIT 1;

-- Attempt duplicate (should FAIL)
INSERT INTO user_match_cache (user_id, recommended_user_id, match_score, match_explanation, algorithm_version)
SELECT
  user_id,
  recommended_user_id,
  75 as match_score,
  '{}' as match_explanation,
  algorithm_version
FROM user_match_cache LIMIT 1;
```

### Out of Scope

This story focuses ONLY on interface definition and database schema creation. The following are explicitly **NOT included**:

- ❌ Implementing any concrete matching engine (e.g., `TagBasedMatchingEngineV1`)
- ❌ Creating `MatchingService` for retrieval
- ❌ API routes for match retrieval
- ❌ Event triggers for automatic recalculation
- ❌ Background job scheduling
- ❌ Cache invalidation logic
- ❌ Unit tests for matching algorithms (no algorithms exist yet)

These will be addressed in subsequent stories (0.23+).

### Reference Documentation

**Architecture Documents:**
1. **Data Models 4.8**: `docs/architecture/4-data-models.md` (Lines 853-970)
   - Complete schema definition
   - Database table structure with all constraints
   - RLS policies

2. **Backend Architecture 8.8**: `docs/architecture/8-backend-architecture.md` (Lines 1880-2097)
   - Full interface definition
   - JSDoc comments with logging requirements
   - Example implementation pattern

3. **Matching Cache Architecture**: `docs/architecture/matching-cache-architecture.md`
   - Event-driven calculation pattern
   - Retrieval optimization strategy
   - Algorithm versioning approach

4. **Coding Standards**: `docs/architecture/14-coding-standards.md`
   - TypeScript conventions
   - Interface naming patterns
   - File organization standards

### Testing

**Testing Approach:**
- Manual database schema validation (no unit tests for this story)
- TypeScript compilation verification
- SQL constraint testing via direct queries
- RLS policy verification

**Test Framework:**
- N/A (infrastructure story - manual validation only)

**Test File Location:**
- N/A (no test files for this story)

**Testing Standards:**
- Verify migration runs: `supabase db reset`
- Verify schema: `\d user_match_cache`
- Verify indexes: `\di user_match_cache*`
- Verify constraints: Insert test queries (see Constraint Testing SQL section)
- Verify TypeScript: `npm run type-check`, `npm run lint`

**Manual Testing Checklist:**
```bash
# 1. Verify table exists
psql -c "SELECT table_name FROM information_schema.tables WHERE table_name = 'user_match_cache';"

# 2. Verify columns
psql -c "\d user_match_cache"

# 3. Verify indexes
psql -c "\di user_match_cache*"

# 4. Verify constraints
psql -c "SELECT conname, contype FROM pg_constraint WHERE conrelid = 'user_match_cache'::regclass;"

# 5. Type check passes
npm run type-check

# 6. Lint passes
npm run lint
```

**Success Criteria:**
This story is **DONE** when:
1. ✅ `supabase db reset` completes without errors
2. ✅ `user_match_cache` table exists with all columns, constraints, indexes
3. ✅ RLS policy allows only coordinators to read
4. ✅ `apps/api/src/providers/matching/interface.ts` exists and exports all interfaces
5. ✅ `npm run type-check` passes
6. ✅ All acceptance criteria checked off

**Estimated Time:** 1-2 hours
- Migration creation: 15 minutes
- Interface definition: 30 minutes
- Testing & validation: 30-45 minutes

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
