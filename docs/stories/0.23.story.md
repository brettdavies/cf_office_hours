# Story 0.23: MATCH-TAG-001

## Status

Ready to Implement

---

## Story

**As a** backend developer,
**I want** a tag-based matching algorithm that pre-calculates and caches match scores in the background,
**so that** coordinators get instant match recommendations without expensive real-time calculations.

## Acceptance Criteria

1. **TagBasedMatchingEngineV1 Class Implementation**
   - File created: `apps/api/src/providers/matching/tag-based.engine.ts`
   - Class implements `IMatchingEngine` interface from Story 0.22
   - Constructor accepts `SupabaseClient` dependency
   - All three interface methods implemented: `recalculateMatches(userId)`, `recalculateAllMatches(options?)`, `getAlgorithmVersion()` returns `'tag-based-v1'`
   - Private helper methods for score calculation: `calculateTagOverlap()` (0-60), `calculateStageMatch()` (0-20), `calculateReputationMatch()` (0-20)
   - TypeScript compilation passes without errors

2. **Tag Overlap Calculation (60% weight)**
   - Fetches all user tags from `entity_tags` table joined with `taxonomy`
   - For mentees: Includes personal tags PLUS portfolio company tags (tag inheritance)
   - Counts shared tags across all categories (industries, technologies, stages)
   - Score formula: `(sharedTagCount / totalUniqueTags) * 60`
   - Returns value between 0-60

3. **Stage Compatibility Calculation (20% weight)**
   - Compares startup stage tags between mentor and mentee
   - Returns 20 points if stages match
   - Returns 10 points if stages are adjacent (e.g., seed ↔ series-a)
   - Returns 0 points if stages differ by >1 level
   - Handles missing stage gracefully (score = 0)

4. **Reputation Compatibility Calculation (20% weight)**
   - Compares `reputation_tier` from users table
   - Tier order: bronze < silver < gold < platinum
   - Returns 20 points if tier difference ≤ 1
   - Returns 0 points if tier difference > 1
   - Handles missing tier gracefully (score = 10, neutral)

5. **Match Explanation Generation**
   - Creates `MatchExplanation` JSONB object with structure: `{ tagOverlap: [{category, tag}], stageMatch: boolean, reputationCompatible: boolean, summary: string }`
   - Includes top 5 shared tags in `tagOverlap` array
   - Summary format: "Strong match: 7 shared tags (fintech, react, seed-stage), same startup stage, compatible reputation tiers"

6. **recalculateMatches() Implementation**
   - Fetches user with profile, tags, and portfolio company data
   - Determines target role: if user is mentor → fetch mentees, else → fetch mentors
   - Fetches all active users with target role (WHERE `deleted_at IS NULL` AND `is_active = true`)
   - Excludes dormant users (WHERE `last_activity_at > NOW() - INTERVAL '90 days'`)
   - Calculates score for each potential match
   - Deletes old cache entries: `DELETE FROM user_match_cache WHERE user_id = $1 AND algorithm_version = 'tag-based-v1'`
   - Inserts new cache entries with all fields: `user_id`, `recommended_user_id`, `match_score`, `match_explanation`, `algorithm_version`, `calculated_at`
   - Transaction ensures atomicity (delete + insert)

7. **recalculateAllMatches() Implementation**
   - Fetches all active users (WHERE `deleted_at IS NULL`)
   - Respects `options.limit` if provided (for testing/gradual rollout)
   - Processes users in batches (default batch size: 100, configurable via `options.batchSize`)
   - Calls `recalculateMatches(userId)` for each user in batch
   - Waits for each batch to complete before starting next batch (sequential batches, parallel within batch)
   - Comprehensive dev-only logging for batch progress

8. **Comprehensive Dev-Only Logging**
   - All log points match architecture specification exactly (Section 8.8)
   - Log format: `[MATCHING] {operation} { contextData }`
   - Minimum 20 log points covering: Entry/exit for each public method, Fetched data counts, Score breakdowns, Cache write operations, Batch processing progress, Error conditions
   - All logs wrapped in `if (process.env.NODE_ENV === 'development')` check
   - No logs in production environment

9. **Centralized Mock Fixtures Created**
   - File created: `apps/api/src/test/fixtures/matching.ts`
   - Factory functions implemented: `createMockUser()`, `createMockUserWithTags()`, `createMockPortfolioCompany()`, `createMockMatchCache()`
   - All factories use `@faker-js/faker` for realistic data
   - All factories support override pattern: `...overrides` spread at end
   - JSDoc comments with usage examples
   - Pre-configured scenarios: `createBronzeMentee()`, `createGoldMentor()`, `createMenteeWithCompany()`

10. **Unit Tests with 85% Coverage**
    - Test file: `apps/api/src/providers/matching/__tests__/tag-based.engine.test.ts`
    - Uses centralized fixtures from `test/fixtures/matching.ts` (MANDATORY - no inline mocks)
    - Test suites cover: Tag overlap scoring, Stage compatibility, Reputation compatibility, Match explanation, Tag inheritance, User filtering, Batch processing, Cache operations, Error handling
    - All tests use Arrange-Act-Assert pattern
    - All tests have descriptive names: "should {expected behavior} when {condition}"
    - Coverage report: `npm run test:coverage` shows ≥85% for tag-based.engine.ts

11. **Code Quality & Standards**
    - Follows coding standards from [14-coding-standards.md](../architecture/14-coding-standards.md)
    - File length <200 lines (if >200, extract helper functions to separate file)
    - All public methods have JSDoc comments with `@param`, `@returns`, `@logging` tags
    - No ESLint errors: `npm run lint` passes
    - No TypeScript errors: `npm run type-check` passes
    - Named exports only (no default exports)
    - Proper error handling with try-catch blocks
    - Database errors wrapped in `AppError` class

## Tasks / Subtasks

- [ ] **Task 1: Create Centralized Mock Fixtures** (AC: 9)
  - [ ] Create directory: `apps/api/src/test/fixtures/`
  - [ ] Create file: `matching.ts`
  - [ ] Implement `createMockUser()` with override pattern
  - [ ] Implement `createMockUserWithTags()` with tags array parameter
  - [ ] Implement `createMockPortfolioCompany()`
  - [ ] Implement `createMockMatchCache()`
  - [ ] Add pre-configured scenarios: `createBronzeMentee()`, `createGoldMentor()`, `createMenteeWithCompany()`
  - [ ] Add JSDoc comments with usage examples
  - [ ] Install `@faker-js/faker` if not already present
  - [ ] Test imports work: `npm run type-check`

- [ ] **Task 2: Implement TagBasedMatchingEngineV1 Class Structure** (AC: 1)
  - [ ] Create file: `apps/api/src/providers/matching/tag-based.engine.ts`
  - [ ] Import `IMatchingEngine`, `BulkRecalculationOptions` from `./interface`
  - [ ] Import `SupabaseClient` from `@supabase/supabase-js`
  - [ ] Define `UserWithTags` interface
  - [ ] Create class: `export class TagBasedMatchingEngineV1 implements IMatchingEngine`
  - [ ] Add constructor: `constructor(private db: SupabaseClient)`
  - [ ] Implement `getAlgorithmVersion()` returning `'tag-based-v1'`
  - [ ] Add stub methods for `recalculateMatches()` and `recalculateAllMatches()`

- [ ] **Task 3: Implement Score Calculation Methods** (AC: 2, 3, 4)
  - [ ] Implement `private calculateTagOverlap(user1, user2): number` - Extract tags, calculate shared/unique, return `(sharedCount / uniqueCount) * 60`
  - [ ] Implement `private calculateStageMatch(user1, user2): number` - Define stage order, calculate difference, return 20/10/0
  - [ ] Implement `private calculateReputationMatch(user1, user2): number` - Define tier order, calculate difference, return 20/0
  - [ ] Implement `private calculateScore(user1, user2): number` - Sum all three scoring methods

- [ ] **Task 4: Implement Match Explanation Generation** (AC: 5)
  - [ ] Implement `private generateExplanation(user1, user2, score): MatchExplanation`
  - [ ] Extract shared tags (top 5)
  - [ ] Map shared tags to `{ category, tag }` objects
  - [ ] Determine `stageMatch` boolean
  - [ ] Determine `reputationCompatible` boolean
  - [ ] Generate human-readable summary string
  - [ ] Return `MatchExplanation` object

- [ ] **Task 5: Implement Tag Inheritance Logic** (AC: 2, 6)
  - [ ] Implement `private async fetchUserWithTags(userId): Promise<UserWithTags>`
  - [ ] Fetch user with user_profiles join
  - [ ] Fetch personal tags from entity_tags
  - [ ] If mentee with portfolio_company_id: fetch company tags
  - [ ] Combine personal + company tags
  - [ ] Return UserWithTags object
  - [ ] Handle missing portfolio company gracefully
  - [ ] Filter out deleted tags (WHERE deleted_at IS NULL)

- [ ] **Task 6: Implement recalculateMatches() Method** (AC: 6)
  - [ ] Fetch user with tags using `fetchUserWithTags(userId)`
  - [ ] Determine target role: `const targetRole = user.role === 'mentor' ? 'mentee' : 'mentor'`
  - [ ] Fetch potential matches with filters (active, non-dormant, target role, exclude self)
  - [ ] For each potential match: Fetch tags, calculate score, generate explanation, create cache entry
  - [ ] Delete old cache entries for user + algorithm
  - [ ] Insert new cache entries (bulk insert)
  - [ ] Add comprehensive dev-only logging (10+ log points)

- [ ] **Task 7: Implement recalculateAllMatches() Method** (AC: 7)
  - [ ] Fetch all active users (WHERE deleted_at IS NULL)
  - [ ] Apply `options.limit` if provided
  - [ ] Extract `batchSize` from options (default: 100)
  - [ ] Split users into batches
  - [ ] For each batch: Process users with `Promise.all()`, log batch progress
  - [ ] Log completion: total processed, average time per user

- [ ] **Task 8: Add Comprehensive Dev-Only Logging** (AC: 8)
  - [ ] Add entry/exit logs for all public methods
  - [ ] Add data fetch logs: user count, tags count, potential matches count
  - [ ] Add score breakdown logs: tag overlap, stage, reputation, total
  - [ ] Add cache operation logs: deleted count, inserted count
  - [ ] Add batch progress logs: current batch, total batches, processed count
  - [ ] Wrap all logs in `if (process.env.NODE_ENV === 'development')` check
  - [ ] Use exact log format: `[MATCHING] {operation} { contextData }`
  - [ ] Match logging specifications from interface.ts JSDoc

- [ ] **Task 9: Write Unit Tests with Centralized Fixtures** (AC: 10)
  - [ ] Create test file: `apps/api/src/providers/matching/__tests__/tag-based.engine.test.ts`
  - [ ] Import fixtures from `@/test/fixtures/matching` (MANDATORY - no inline mocks)
  - [ ] Write test suite: `describe('TagBasedMatchingEngineV1')`
  - [ ] Test `getAlgorithmVersion()` returns `'tag-based-v1'`
  - [ ] Test `calculateTagOverlap()`: full match (60), no match (0), partial match
  - [ ] Test `calculateStageMatch()`: same (20), adjacent (10), different (0), missing (0)
  - [ ] Test `calculateReputationMatch()`: compatible (20), incompatible (0), missing (10)
  - [ ] Test tag inheritance: mentee includes company tags, mentor excludes company tags
  - [ ] Test `recalculateMatches()`: writes to cache, deletes old entries, inserts new entries
  - [ ] Test `recalculateAllMatches()`: processes batches, respects limit, handles empty list
  - [ ] Test error handling: missing user, database errors
  - [ ] Run coverage: `npm run test:coverage -- tag-based.engine.test.ts`
  - [ ] Verify ≥85% coverage

- [ ] **Task 10: Code Quality & Documentation** (AC: 11)
  - [ ] Add JSDoc comments to all public methods with `@param`, `@returns`, `@logging` tags
  - [ ] Add file header comment explaining algorithm
  - [ ] Add inline comments for complex logic (tag inheritance, score weighting)
  - [ ] Run `npm run lint` - fix all errors
  - [ ] Run `npm run type-check` - fix all errors
  - [ ] Check file length: if >200 lines, extract helpers to separate file
  - [ ] Verify named exports only (no default exports)
  - [ ] Add error handling with try-catch blocks
  - [ ] Wrap database errors in `AppError` class

## Dev Notes

### Overview

This story implements the first concrete matching algorithm (`TagBasedMatchingEngineV1`) following the `IMatchingEngine` interface created in Story 0.22. The algorithm calculates match scores based on:
- **Tag overlap** (60%): Shared industries, technologies, and stages
- **Stage compatibility** (20%): Similar startup stage
- **Reputation compatibility** (20%): Tier difference ≤ 1

The engine runs in the background, writing pre-calculated scores to the `user_match_cache` table.

### Architecture Context

**Event-Driven Cache Architecture** ([matching-cache-architecture.md](../architecture/matching-cache-architecture.md)):

This story implements the **calculation** side of the two-operation matching system:

1. **CALCULATE (this story)**: Expensive, polymorphic, background processing
   - Input: User A, User B, algorithm logic
   - Output: Score (0-100), explanation
   - Writes to `user_match_cache` table
   - **Interface**: `IMatchingEngine` (supports multiple algorithms)

2. **RETRIEVE (Story 0.24)**: Cheap, NOT polymorphic, on-demand
   - Input: User ID, optional filters
   - Output: Cached MatchResults
   - Reads from `user_match_cache` table
   - **No interface**: Plain `MatchingService` class

**Key Principle**: Algorithm version is data (column filter), not behavior. Multiple algorithms can coexist in the cache table, differentiated by `algorithm_version` string.

**Key Architecture Principles**:
- **Calculation is polymorphic** → Implements `IMatchingEngine` interface
- **Event-driven execution** → Triggered by data changes (implemented in Story 0.25)
- **Algorithm version stamped** → All cache entries tagged with `'tag-based-v1'`
- **Mentee tag inheritance** → Mentees inherit tags from their portfolio company

### Previous Story Insights

**From Story 0.22**:
- `IMatchingEngine` interface created in `apps/api/src/providers/matching/interface.ts`
- `user_match_cache` table exists with indexes on `user_id`, `match_score DESC`, `algorithm_version`, `calculated_at`
- RLS policy: Only coordinators can read cache table
- All logging format specifications defined in interface JSDoc

### Data Models

**Source**: [4-data-models.md](../architecture/4-data-models.md) Section 4.8

**User Match Cache Table Schema**:
```sql
CREATE TABLE user_match_cache (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  recommended_user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  match_score numeric(5,2) NOT NULL CHECK (match_score >= 0 AND match_score <= 100),
  match_explanation jsonb NOT NULL,
  algorithm_version text NOT NULL,
  calculated_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE(user_id, recommended_user_id, algorithm_version),
  CHECK (user_id != recommended_user_id)
);
```

### Required Database Queries

**1. Fetch user with tags** (includes tag inheritance for mentees):
```typescript
// Fetch user with profile
const { data: user } = await db
  .from('users')
  .select('*, user_profiles(*)')
  .eq('id', userId)
  .single();

// Fetch user's personal tags
const { data: personalTags } = await db
  .from('entity_tags')
  .select('taxonomy(*)')
  .eq('entity_type', 'user')
  .eq('entity_id', userId)
  .is('deleted_at', null);

// If mentee: Fetch portfolio company tags
if (user.role === 'mentee' && user.user_profiles.portfolio_company_id) {
  const { data: companyTags } = await db
    .from('entity_tags')
    .select('taxonomy(*)')
    .eq('entity_type', 'portfolio_company')
    .eq('entity_id', user.user_profiles.portfolio_company_id)
    .is('deleted_at', null);

  // Combine personal + company tags
  effectiveTags = [...personalTags, ...companyTags];
}
```

**2. Fetch potential matches** (active, non-dormant, target role):
```typescript
const { data: potentialMatches } = await db
  .from('users')
  .select('*, user_profiles(*)')
  .eq('role', targetRole) // 'mentor' or 'mentee'
  .eq('is_active', true)
  .is('deleted_at', null)
  .gt('last_activity_at', new Date(Date.now() - 90 * 24 * 60 * 60 * 1000)) // Active within 90 days
  .neq('id', userId); // Exclude self
```

**3. Write to cache** (atomic delete + insert):
```typescript
// Delete old cache entries for this user + algorithm
await db
  .from('user_match_cache')
  .delete()
  .eq('user_id', userId)
  .eq('algorithm_version', 'tag-based-v1');

// Insert new cache entries
const cacheEntries = matchResults.map(match => ({
  user_id: userId,
  recommended_user_id: match.id,
  match_score: match.score,
  match_explanation: match.explanation,
  algorithm_version: 'tag-based-v1',
  calculated_at: new Date()
}));

await db
  .from('user_match_cache')
  .insert(cacheEntries);
```

### Scoring Algorithm Details

**Source**: [8-backend-architecture.md](../architecture/8-backend-architecture.md) Lines 1948-2105

**Formula**: `(tagOverlap × 60%) + (stageMatch × 20%) + (reputationMatch × 20%)`

**1. Tag Overlap (0-60 points)**:
```typescript
private calculateTagOverlap(user1Tags: string[], user2Tags: string[]): number {
  const sharedTags = user1Tags.filter(tag => user2Tags.includes(tag));
  const uniqueTags = new Set([...user1Tags, ...user2Tags]);

  if (uniqueTags.size === 0) return 0;

  const overlapRatio = sharedTags.length / uniqueTags.size;
  return Math.round(overlapRatio * 60);
}
```

**2. Stage Match (0-20 points)**:
```typescript
private calculateStageMatch(user1Stage: string | null, user2Stage: string | null): number {
  if (!user1Stage || !user2Stage) return 0;

  const stageOrder = ['pre-seed', 'seed', 'series-a', 'series-b', 'series-c', 'growth'];
  const index1 = stageOrder.indexOf(user1Stage);
  const index2 = stageOrder.indexOf(user2Stage);

  if (index1 === -1 || index2 === -1) return 0;

  const difference = Math.abs(index1 - index2);
  if (difference === 0) return 20; // Same stage
  if (difference === 1) return 10; // Adjacent stages
  return 0; // Different stages
}
```

**3. Reputation Match (0-20 points)**:
```typescript
private calculateReputationMatch(user1Tier: string | null, user2Tier: string | null): number {
  if (!user1Tier || !user2Tier) return 10; // Neutral if missing

  const tierOrder = ['bronze', 'silver', 'gold', 'platinum'];
  const index1 = tierOrder.indexOf(user1Tier);
  const index2 = tierOrder.indexOf(user2Tier);

  if (index1 === -1 || index2 === -1) return 10;

  const difference = Math.abs(index1 - index2);
  return difference <= 1 ? 20 : 0; // Compatible if tier difference ≤ 1
}
```

**4. Match Explanation**:
```typescript
private generateExplanation(user1Tags: string[], user2Tags: string[], stageMatch: number, repMatch: number): MatchExplanation {
  const sharedTags = user1Tags.filter(tag => user2Tags.includes(tag))
    .slice(0, 5) // Top 5 shared tags
    .map(tag => ({
      category: getTagCategory(tag), // 'industry', 'technology', or 'stage'
      tag: tag
    }));

  const summary = `${sharedTags.length > 0 ? 'Strong' : 'Weak'} match: ${sharedTags.length} shared tags` +
    `${stageMatch === 20 ? ', same startup stage' : ''}` +
    `${repMatch === 20 ? ', compatible reputation tiers' : ''}`;

  return {
    tagOverlap: sharedTags,
    stageMatch: stageMatch === 20,
    reputationCompatible: repMatch === 20,
    summary
  };
}
```

### File Locations

**Source**: [9-unified-project-structure.md](../architecture/9-unified-project-structure.md)

```
apps/api/src/
├── providers/
│   └── matching/
│       ├── interface.ts                    # ✅ Created in Story 0.22
│       ├── tag-based.engine.ts             # 🎯 THIS STORY (main implementation)
│       └── __tests__/
│           └── tag-based.engine.test.ts    # 🎯 THIS STORY (unit tests)
├── test/
│   └── fixtures/
│       └── matching.ts                     # 🎯 THIS STORY (centralized mock factories)
└── lib/
    ├── db.ts                               # ✅ Supabase client (already exists)
    └── errors.ts                           # ✅ AppError class (already exists)
```

### TypeScript Types

**Import from Story 0.22**:
```typescript
import type {
  IMatchingEngine,
  BulkRecalculationOptions,
  MatchExplanation,
  UserMatchCache
} from './interface';
```

**Additional types needed** (define in tag-based.engine.ts):
```typescript
interface UserWithTags {
  id: string;
  email: string;
  role: 'mentor' | 'mentee' | 'coordinator';
  reputation_tier: 'bronze' | 'silver' | 'gold' | 'platinum' | null;
  is_active: boolean;
  last_activity_at: Date | null;
  deleted_at: Date | null;
  user_profiles: {
    portfolio_company_id: string | null;
    stage: string | null;
  };
  tags: string[]; // Effective tags (personal + company for mentees)
}
```

### Out of Scope

This story focuses ONLY on the matching engine calculation logic. The following are explicitly **NOT included**:

- API endpoints for match retrieval (Story 0.24)
- `MatchingService` class for cache retrieval (Story 0.24)
- Event triggers for automatic recalculation (Story 0.25)
- Background job scheduling/cron setup (Story 0.25)
- Frontend UI for displaying matches (Epic 6)
- Match filtering or sorting logic (Story 0.24)
- Admin tools for manual recalculation (Epic 8)
- ML-based matching algorithms (future enhancement)

### Testing

**Source**: [13-testing-strategy.md](../architecture/13-testing-strategy.md) Section 13.7, Lines 1646-1773

**Coverage Target**: 85% for `tag-based.engine.ts`

**Test Framework**: Vitest 3.x
**Test File**: `apps/api/src/providers/matching/__tests__/tag-based.engine.test.ts`
**Fixtures**: `apps/api/src/test/fixtures/matching.ts` (MANDATORY - Section 13.7)

#### Centralized Mock Fixtures (CRITICAL)

**MANDATORY REQUIREMENT** (Section 14.11.2, Section 13.7):

All test mock data MUST use centralized factory functions. DO NOT create inline mock objects in test files.

**Factory Location**: `apps/api/src/test/fixtures/matching.ts`

**Required Factories**:
```typescript
// apps/api/src/test/fixtures/matching.ts
import { faker } from '@faker-js/faker';

/**
 * Creates a mock user with default values
 * @example
 * const user = createMockUser({ role: 'mentor', reputation_tier: 'gold' });
 */
export function createMockUser(overrides?: Partial<User>): User {
  return {
    id: faker.string.uuid(),
    email: faker.internet.email(),
    name: faker.person.fullName(),
    role: 'mentee',
    reputation_tier: 'silver',
    is_active: true,
    last_activity_at: new Date(),
    deleted_at: null,
    created_at: new Date(),
    updated_at: new Date(),
    ...overrides,
  };
}

/**
 * Creates a mock user with tags (includes user_profiles)
 */
export function createMockUserWithTags(overrides?: Partial<UserWithTags> & { tags?: string[] }): UserWithTags {
  return {
    ...createMockUser(),
    user_profiles: {
      portfolio_company_id: null,
      stage: 'seed',
      ...overrides?.user_profiles,
    },
    tags: overrides?.tags || ['fintech', 'react', 'seed-stage'],
    ...overrides,
  };
}

/**
 * Pre-configured scenario: Bronze mentee
 */
export function createBronzeMentee(): UserWithTags {
  return createMockUserWithTags({
    role: 'mentee',
    reputation_tier: 'bronze',
    tags: ['fintech', 'seed-stage']
  });
}

/**
 * Pre-configured scenario: Gold mentor
 */
export function createGoldMentor(): UserWithTags {
  return createMockUserWithTags({
    role: 'mentor',
    reputation_tier: 'gold',
    tags: ['fintech', 'react', 'series-a']
  });
}
```

#### Test Execution Commands

```bash
# Run unit tests for matching engine
npm run test -- tag-based.engine.test.ts

# Run with coverage report
npm run test:coverage -- tag-based.engine.test.ts

# Watch mode for development
npm run test:watch -- tag-based.engine.test.ts
```

#### Coverage Requirements

- **Line coverage**: ≥85%
- **Branch coverage**: ≥80%
- **Function coverage**: 100%

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | 1.0 | Initial story draft created | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

## QA Results

_To be filled by QA agent_
