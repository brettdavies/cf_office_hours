# 4. Data Models

Based on the PRD requirements and database schema design, the following TypeScript interfaces define the core data models/entities that will be shared between frontend and backend. These interfaces will live in `packages/shared` for type safety across the stack.

## 4.1 User & Profile Models

**Purpose:** Represents system users with role-based access and reputation tracking

**Key Attributes:**
- `id`: UUID - Primary identifier
- `airtable_record_id`: string - Stable external reference from Airtable source of truth
- `email`: string - Authentication and communication
- `role`: UserRole enum - Access control (mentee, mentor, coordinator) - **Single role per user in MVP**
- `reputation_score`: number - Calculated value (default 3.5 for cold start per FR47)
- `reputation_tier`: ReputationTier enum - Derived tier (bronze, silver, gold, platinum)
- `is_active`: boolean - Soft delete flag synced from Airtable
- `last_activity_at`: timestamp - Tracks dormancy (90+ days = dormant per FR57)

**TypeScript Interface:**

```typescript
// packages/shared/src/types/user.ts

export enum UserRole {
  Mentee = 'mentee',
  Mentor = 'mentor',
  Coordinator = 'coordinator',
}

export enum ReputationTier {
  Bronze = 'bronze',   // 0-3.0: 2 bookings/week max
  Silver = 'silver',   // 3.0-4.0: 5 bookings/week max
  Gold = 'gold',       // 4.0-4.5: 10 bookings/week max
  Platinum = 'platinum' // 4.5+: Unlimited bookings
}

export interface User {
  id: string;
  airtable_record_id: string;
  email: string;
  role: UserRole;
  reputation_score: number;
  reputation_tier: ReputationTier;
  is_active: boolean;
  last_activity_at: Date;
  created_at: Date;
  updated_at: Date;
  deleted_at: Date | null;
}

export interface UserProfile {
  id: string;
  user_id: string;
  name: string;
  title: string | null;
  company: string | null;
  phone: string | null;
  linkedin_url: string | null;
  website_url: string | null;
  pitch_vc_url: string | null; // Mentee-specific
  expertise_description: string | null; // Mentor-specific
  ideal_mentee_description: string | null; // Mentor-specific
  bio: string | null;
  avatar_url: string | null;
  avatar_source_type: 'upload' | 'url' | null;
  avatar_metadata: AvatarCropSettings | null;
  reminder_preference: ReminderPreference;
  additional_links: Record<string, string>; // Flexible JSONB
  metadata: Record<string, any>; // Experimentation escape hatch
  created_at: Date;
  updated_at: Date;
}

export interface AvatarCropSettings {
  zoom: number;
  pan_x: number;
  pan_y: number;
  rotation: number;
}

export enum ReminderPreference {
  OneHour = 'one_hour',
  TwentyFourHours = 'twenty_four_hours',
  Both = 'both',
}

// Combined view for API responses
export interface UserWithProfile extends User {
  profile: UserProfile;
}
```

**Relationships:**
- User → UserProfile (1:1)
- User → UserTags (1:many)
- User → Bookings as mentor/mentee (1:many)
- User → CalendarIntegration (1:1, optional except for non-coordinators per FR105)

## 4.2 Tag & Taxonomy Models

**Purpose:** Industry/technology/stage categorization for matching and filtering

**Key Attributes:**
- `category`: TagCategory enum - Type of classification
- `tag_value`: string - Machine-readable value (**normalized to lowercase_snake_case**)
- `source`: TagSource enum - Origin of tag (airtable, user, auto_generated, admin)
- `is_confirmed`: boolean - Whether user has confirmed the tag
- `is_approved`: boolean - For taxonomy entries, whether coordinator approved

**TypeScript Interface:**

```typescript
// packages/shared/src/types/tag.ts

export enum TagCategory {
  Industry = 'industry',
  Technology = 'technology',
  Stage = 'stage',
}

export enum TagSource {
  Airtable = 'airtable',     // Synced from Airtable (auto-confirmed)
  User = 'user',             // User manually selected from taxonomy
  AutoGenerated = 'auto_generated', // System suggested (future AI feature)
  Admin = 'admin',           // Coordinator added
}

export interface UserTag {
  id: string;
  user_id: string;
  category: TagCategory;
  tag_value: string;
  is_confirmed: boolean;
  source: TagSource;
  confirmed_at: Date | null;
  confirmed_by: string | null; // User ID who confirmed
  created_at: Date;
  updated_at: Date;
  deleted_at: Date | null;
}

export interface TaxonomyEntry {
  id: string;
  airtable_record_id: string | null; // Null for user-submitted
  category: TagCategory;
  value: string; // Machine-readable, lowercase_snake_case (e.g., "artificial_intelligence")
  display_name: string; // Human-readable (e.g., "Artificial Intelligence")
  source: TagSource;
  is_approved: boolean;
  requested_by: string | null; // User ID for user_request source
  approved_by: string | null; // Coordinator user ID
  requested_at: Date | null;
  approved_at: Date | null;
  created_at: Date;
  updated_at: Date;
}
```

**Tag Normalization:**
- Backend always converts `value` to lowercase_snake_case
- Original input stored in `display_name`
- Database unique constraint on `LOWER(value)` prevents duplicates

**Relationships:**
- UserTag → User (many:1)
- UserTag → TaxonomyEntry (many:1 via category + tag_value lookup)

## 4.3 Availability & Booking Models

**Purpose:** Mentor availability scheduling and booking management

**Key Design Notes:**
- Availability blocks define recurring patterns (weekly, monthly, etc.)
- Time slots are generated instances from availability blocks
- **Time Slot Generation Strategy:**
  - Generate slots for next 30 days on availability block save
  - Background job (triggered on coordinator login) generates next 30 days weekly (rolling window)
  - Keeps `time_slots` table manageable (~500 mentors × 4 blocks × 30 slots = 60k rows max)
- Bookings link mentees to specific time slots with meeting details

**TypeScript Interface:**

```typescript
// packages/shared/src/types/availability.ts

export enum RecurrencePattern {
  OneTime = 'one_time',
  Weekly = 'weekly',
  Monthly = 'monthly',
  Quarterly = 'quarterly',
}

export enum MeetingType {
  InPersonPreset = 'in_person_preset',
  InPersonCustom = 'in_person_custom',
  Online = 'online',
}

export interface AvailabilityBlock {
  id: string;
  mentor_id: string;
  recurrence_pattern: RecurrencePattern;
  start_date: string; // ISO date string (YYYY-MM-DD)
  end_date: string | null; // Null for ongoing
  start_time: string; // Time only (HH:MM:SS)
  end_time: string; // Time only (HH:MM:SS)
  slot_duration_minutes: 15 | 20 | 30 | 60;
  buffer_minutes: number;
  meeting_type: MeetingType;
  location_preset_id: string | null;
  location_custom: string | null;
  description: string | null;
  created_at: Date;
  updated_at: Date;
  deleted_at: Date | null;
}

export interface TimeSlot {
  id: string;
  availability_block_id: string;
  mentor_id: string;
  start_time: Date; // Full UTC datetime
  end_time: Date; // Full UTC datetime
  is_booked: boolean;
  booking_id: string | null;
  created_at: Date;
  deleted_at: Date | null;
}

export enum BookingStatus {
  Confirmed = 'confirmed',
  Completed = 'completed',
  Canceled = 'canceled',
}

export enum CancellationReason {
  Emergency = 'emergency',
  Reschedule = 'reschedule',
  Other = 'other',
}

export interface Booking {
  id: string;
  time_slot_id: string;
  mentor_id: string;
  mentee_id: string;
  meeting_goal: string; // Required, min 10 chars
  materials_urls: string[];
  meeting_type: MeetingType;
  location: string | null;
  google_meet_link: string | null; // Auto-generated per FR62
  status: BookingStatus;
  canceled_by: string | null; // User ID
  canceled_at: Date | null;
  cancellation_reason: CancellationReason | null;
  cancellation_notes: string | null;
  meeting_start_time: Date;
  meeting_end_time: Date;
  created_at: Date;
  updated_at: Date;
  deleted_at: Date | null;
}

// Extended booking with participant details for UI
export interface BookingWithParticipants extends Booking {
  mentor: UserWithProfile;
  mentee: UserWithProfile;
  time_slot: TimeSlot;
}
```

**Relationships:**
- AvailabilityBlock → TimeSlots (1:many, generated)
- TimeSlot → Booking (1:1, when booked)
- Booking → User (many:1 for mentor, many:1 for mentee)

## 4.4 Reputation & Rating Models

**Purpose:** Track user ratings and calculate reputation scores with tier assignment

**Key Attributes:**
- Ratings are 1-5 star reviews after meetings
- Reputation history tracks score changes and calculation details
- **Mentor-specific exception requests** handle tier restriction bypass per FR54
- **Responsiveness Factor Calculation:**
  - Default: 1.0× multiplier
  - Late cancellation (within 2hrs per FR60): 0.8× penalty
  - Time between mentor-initiated override request creation and booking acceptance (tracked for future enhancements)

**TypeScript Interface:**

```typescript
// packages/shared/src/types/reputation.ts

export interface Rating {
  id: string;
  booking_id: string;
  rater_id: string; // Who gave the rating
  rated_user_id: string; // Who received the rating
  score: 1 | 2 | 3 | 4 | 5;
  feedback_text: string | null;
  created_at: Date;
  deleted_at: Date | null;
}

export enum ReputationTrigger {
  RatingReceived = 'rating_received',
  MeetingCompleted = 'meeting_completed',
  MeetingCanceled = 'meeting_canceled',
  AdminOverride = 'admin_override',
}

export interface ReputationCalculationDetails {
  average_rating: number;
  completion_rate: number;
  responsiveness_factor: number; // 1.0× default, 0.8× for late cancellations
  tenure_bonus: number;
  raw_score: number;
  probationary_clamp_applied: boolean;
  ratings_count: number;
}

export interface ReputationHistory {
  id: string;
  user_id: string;
  old_score: number | null;
  new_score: number;
  old_tier: ReputationTier | null;
  new_tier: ReputationTier;
  calculation_details: ReputationCalculationDetails;
  trigger_event: ReputationTrigger;
  created_at: Date;
}

export enum OverrideStatus {
  Pending = 'pending',
  Approved = 'approved',
  Denied = 'denied',
}

export enum OverrideScope {
  OneTime = 'one_time', // MVP: Single booking with specific mentor within 7 days
}

// NOTE: Tier-based overrides not supported in MVP - only mentor-specific exceptions
export interface TierOverrideRequest {
  id: string;
  mentee_id: string;
  mentor_id: string; // Specific mentor (not tier-based)
  reason: string;
  status: OverrideStatus;
  scope: OverrideScope;
  expires_at: Date; // 7 days from approval (or creation for pending)
  used_at: Date | null; // When booking was made using this override
  reviewed_by: string | null; // Coordinator user ID
  reviewed_at: Date | null;
  review_notes: string | null;
  created_at: Date;
  updated_at: Date;
}

// Extended view for coordinator dashboard
export interface TierOverrideRequestWithUsers extends TierOverrideRequest {
  mentee: UserWithProfile;
  mentor: UserWithProfile;
  reviewer: UserWithProfile | null;
}
```

**Optimistic Locking for Override Approvals:**
- Use `UPDATE WHERE status = 'pending'` to prevent duplicate approvals
- First coordinator approval wins
- Second attempt returns 409 Conflict

**Relationships:**
- Rating → Booking (many:1)
- Rating → User as rater (many:1)
- Rating → User as rated (many:1)
- ReputationHistory → User (many:1)
- TierOverrideRequest → User as mentee (many:1)
- TierOverrideRequest → User as mentor (many:1)

## 4.5 Calendar Integration Models

**Purpose:** OAuth calendar connectivity for Google/Microsoft calendars per FR21/FR105

**Key Attributes:**
- OAuth tokens and refresh tokens for calendar API access
- Multi-calendar support (select which calendars to read/write)
- Connection method tracks OAuth signup vs post-login connection

**TypeScript Interface:**

```typescript
// packages/shared/src/types/calendar.ts

export enum CalendarProvider {
  Google = 'google',
  Microsoft = 'microsoft',
}

export enum ConnectionMethod {
  OAuthSignup = 'oauth_signup',     // FR2: Combined auth + calendar during signup
  PostLogin = 'post_login',         // Magic link users connect post-auth
}

export interface CalendarInfo {
  id: string;
  name: string;
  is_primary: boolean;
  color: string | null;
}

export interface CalendarIntegration {
  id: string;
  user_id: string;
  provider: CalendarProvider;
  access_token: string; // Encrypted at rest
  refresh_token: string; // Encrypted at rest
  token_expires_at: Date;
  granted_scopes: string[]; // OAuth scopes granted
  connection_method: ConnectionMethod;
  is_connected: boolean;
  available_calendars: CalendarInfo[];
  write_calendar_id: string | null; // Which calendar to create events in
  read_calendar_ids: string[]; // Which calendars to check for conflicts
  last_sync_at: Date | null;
  created_at: Date;
  updated_at: Date;
}

// API response for calendar sync status
export interface CalendarSyncStatus {
  is_connected: boolean;
  provider: CalendarProvider | null;
  last_sync_at: Date | null;
  calendars_count: number;
}
```

**Relationships:**
- CalendarIntegration → User (1:1, unique constraint per user in MVP)

## 4.6 Notification & Audit Models

**Purpose:** Track notification delivery and admin actions for compliance

**TypeScript Interface:**

```typescript
// packages/shared/src/types/notification.ts

export enum NotificationType {
  BookingConfirmed = 'booking_confirmed',
  BookingCancelled = 'booking_cancelled',
  BookingReminder = 'booking_reminder',
  RatingRequest = 'rating_request',
  TierChanged = 'tier_changed',
  MentorReachOut = 'mentor_reach_out',
  OverrideApproved = 'override_approved',
  OverrideRejected = 'override_rejected',
  TagApprovalPending = 'tag_approval_pending',
}

export enum DeliveryChannel {
  Email = 'email',
  Toast = 'toast',
  Both = 'both',
}

export enum DeliveryStatus {
  Sent = 'sent',
  Failed = 'failed',
}

export interface NotificationLog {
  id: string;
  notification_type: NotificationType;
  recipient_id: string;
  delivery_channel: DeliveryChannel;
  delivery_status: DeliveryStatus;
  error_message: string | null;
  metadata: Record<string, any>; // booking_id, mentor_id, etc.
  sent_at: Date | null;
  created_at: Date;
}

export interface AuditLog {
  id: string;
  action_type: string; // 'reputation_override', 'meeting_canceled', etc.
  admin_user_id: string;
  target_entity_type: string; // 'booking', 'user', etc.
  target_entity_id: string;
  before_value: Record<string, any> | null;
  after_value: Record<string, any> | null;
  reason: string | null;
  created_at: Date;
}
```

**Relationships:**
- NotificationLog → User (many:1 recipient)
- AuditLog → User (many:1 admin)

## 4.7 Edge Case Handling

**User Deletion (Airtable Sync):**
- Soft delete user (`is_active = false`)
- Send notification to BOTH parties + coordinators
- **24-hour undo window:** Coordinator can manually reactivate
- After 24hrs, meetings auto-cancel permanently

**Rating After User Deletion:**
- Deleted users (`deleted_at IS NOT NULL`) cannot submit ratings
- Other parties in the meeting can still rate the deleted user

**Mutual Availability Indicator:**
- Best-effort indication (not guarantee)
- Booking confirmation checks BOTH calendars via API (FR106)
- If conflict detected: Show error, remove ⭐ indicator, refresh slot list
- User picks different slot

---
